================================================================================
         PLANO DE ETAPAS DE DESENVOLVIMENTO - SISTEMA DE RESTAURAÃ‡ÃƒO
              Operador Digital de Atendimento Multi-Unidade
                        Data: 10 de Fevereiro de 2026
                          ðŸ”„ REORGANIZADO - BACKEND FIRST
================================================================================

âš ï¸  MUDANÃ‡A DE ESTRATÃ‰GIA - LEIA COM ATENÃ‡ÃƒO âš ï¸
===============================================

Este projeto estÃ¡ em FASE DE BACKEND PURO.
Nenhuma interface grÃ¡fica (UI), mobile ou web deve ser considerada agora.

O sistema Ã© um MOTOR OPERACIONAL para ambientes de consumo humano
(restaurantes, bares, hotÃ©is, discotecas), onde o principal problema
nÃ£o Ã© visual, mas sim CAOS OPERACIONAL, concorrÃªncia e falta de
rastreabilidade.

PRINCÃPIOS FUNDAMENTAIS:
â†’ Backend Ã© a ÃšNICA fonte de verdade
â†’ Organiza pessoas e processos
â†’ Funciona corretamente mesmo em ambientes caÃ³ticos
â†’ Independente de qualquer UI futura
â†’ DomÃ­nio > Controller > Infraestrutura
â†’ Services pequenos, testÃ¡veis e previsÃ­veis
â†’ Regras explÃ­citas, nunca implÃ­citas


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ESTADO ATUAL - JÃ IMPLEMENTADO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… ETAPA 01 - ANÃLISE ARQUITETURAL COMPLETA
   â€¢ AvaliaÃ§Ã£o de estrutura existente
   â€¢ IdentificaÃ§Ã£o de gaps crÃ­ticos
   â€¢ DefiniÃ§Ã£o de roadmap
   â€¢ AderÃªncia: 41% aos princÃ­pios arquiteturais

âœ… ETAPA 02 - FUNDAÃ‡Ã•ES DE CONCORRÃŠNCIA E AUDITORIA
   â€¢ @Version em todas entities crÃ­ticas
   â€¢ BaseEntity com createdBy/updatedBy
   â€¢ AuditorAware com SecurityContext
   â€¢ GlobalExceptionHandler para OptimisticLockException
   â€¢ Testes de concorrÃªncia automatizados

âœ… ETAPA 03 - MODELO DE DOMÃNIO OPERACIONAL
   â€¢ UnidadeDeConsumo (refatorado de Mesa)
   â€¢ SubPedido com status independente
   â€¢ ItemSubPedido
   â€¢ Cozinha e UnidadeAtendimento
   â€¢ TipoCozinha e TipoUnidadeAtendimento (enums)
   â€¢ Roteamento automÃ¡tico de SubPedidos
   â€¢ Load balancing entre cozinhas

âœ… ETAPA 04 - EVENT LOG E MÃQUINA DE ESTADOS
   â€¢ PedidoEventLog (imutÃ¡vel)
   â€¢ SubPedidoEventLog (com mÃ©tricas de tempo)
   â€¢ EventLogService (16 mÃ©todos)
   â€¢ 17 queries especializadas
   â€¢ 15 endpoints REST para anÃ¡lise
   â€¢ Rastreabilidade total

âœ… ETAPA 05 - SEGURANÃ‡A JWT + RBAC
   â€¢ Spring Security configurado
   â€¢ JWT tokens (access 24h + refresh 7d)
   â€¢ 5 roles hierÃ¡rquicos: CLIENTE â†’ ATENDENTE â†’ GERENTE â†’ COZINHA â†’ ADMIN
   â€¢ @PreAuthorize em endpoints crÃ­ticos
   â€¢ User entity com UserDetails
   â€¢ AuditorAware integrado

âœ… ETAPA 06 - QR CODE SEGURO COM ZXING
   â€¢ QrCodeToken entity com UUID Ãºnico
   â€¢ 3 tipos: MESA (24h), ENTREGA (30min), PAGAMENTO (1h)
   â€¢ 4 status: ATIVO, USADO, EXPIRADO, CANCELADO
   â€¢ ZXing 3.5.3 para geraÃ§Ã£o de imagens PNG
   â€¢ 3 jobs agendados (expiraÃ§Ã£o, renovaÃ§Ã£o, limpeza)
   â€¢ 8 endpoints REST
   â€¢ ValidaÃ§Ã£o automÃ¡tica de expiraÃ§Ã£o

RESULTADO:
â€¢ 107 arquivos Java compilados
â€¢ ~15.000 linhas de cÃ³digo
â€¢ BUILD SUCCESS
â€¢ Sistema operacional com fundaÃ§Ãµes sÃ³lidas


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
NOVA ORDEM DE DESENVOLVIMENTO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

A ordem foi REORGANIZADA para focar no MOTOR OPERACIONAL do backend
antes de qualquer camada de apresentaÃ§Ã£o.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ETAPA PRIORITÃRIA 1 â€” MOTOR OPERACIONAL DE PEDIDOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STATUS: ðŸ”µ PRÃ“XIMA ETAPA

OBJETIVO:
Definir, validar e implementar o ciclo de vida completo do pedido
exclusivamente no BACKEND. Criar mÃ¡quina de estados robusta que
organiza o caos operacional sem depender de UI.

CONTEXTO:
Pedidos em ambientes reais enfrentam:
â€¢ MÃºltiplos atores (cliente, garÃ§om, cozinha, balcÃ£o)
â€¢ ConcorrÃªncia (vÃ¡rios garÃ§ons, vÃ¡rias cozinhas)
â€¢ InterrupÃ§Ãµes (cancelamentos, mudanÃ§as de prioridade)
â€¢ Caos operacional (falta de comunicaÃ§Ã£o, atrasos)

O backend DEVE organizar este caos atravÃ©s de regras explÃ­citas.

ATIVIDADES:
â–¡ Revisar estados atuais de SubPedido e Pedido
â–¡ Definir estados oficiais da mÃ¡quina de estados:
  â€¢ CRIADO - Pedido registrado, aguardando confirmaÃ§Ã£o
  â€¢ PENDENTE - Confirmado, aguardando inÃ­cio de preparaÃ§Ã£o
  â€¢ EM_PREPARACAO - Sendo preparado pela cozinha
  â€¢ PRONTO - Preparado, aguardando retirada/entrega
  â€¢ EM_ENTREGA - Sendo entregue ao cliente (garÃ§om pegou)
  â€¢ ENTREGUE - Entregue ao cliente (confirmado)
  â€¢ CANCELADO - Cancelado (com motivo obrigatÃ³rio)

â–¡ Definir transiÃ§Ãµes vÃ¡lidas e BLOQUEAR transiÃ§Ãµes invÃ¡lidas:
  â€¢ CRIADO â†’ PENDENTE (automÃ¡tico ou manual)
  â€¢ CRIADO â†’ CANCELADO (apenas GERENTE/ADMIN)
  â€¢ PENDENTE â†’ EM_PREPARACAO (cozinha assume)
  â€¢ PENDENTE â†’ CANCELADO (apenas GERENTE/ADMIN)
  â€¢ EM_PREPARACAO â†’ PRONTO (cozinha finaliza)
  â€¢ EM_PREPARACAO â†’ CANCELADO (apenas GERENTE/ADMIN com justificativa)
  â€¢ PRONTO â†’ EM_ENTREGA (garÃ§om assume)
  â€¢ EM_ENTREGA â†’ ENTREGUE (garÃ§om confirma)
  â€¢ EM_ENTREGA â†’ PRONTO (devoluÃ§Ã£o - item rejeitado pelo cliente)
  â€¢ PROIBIDO: ENTREGUE â†’ qualquer estado (terminal)
  â€¢ PROIBIDO: CANCELADO â†’ qualquer estado (terminal)

â–¡ Criar StateMachine ou validator no Service layer
â–¡ Implementar validaÃ§Ãµes de permissÃ£o por role:
  â€¢ CLIENTE: pode criar, nÃ£o pode alterar estados
  â€¢ COZINHA: PENDENTE â†’ EM_PREPARACAO â†’ PRONTO
  â€¢ ATENDENTE (garÃ§om): PRONTO â†’ EM_ENTREGA â†’ ENTREGUE
  â€¢ GERENTE/ADMIN: pode cancelar em qualquer estado (exceto terminais)

â–¡ Implementar regras de negÃ³cio:
  â€¢ Cancelamento EXIGE motivo (campo obrigatÃ³rio)
  â€¢ SubPedido sÃ³ pode ser cancelado se nÃ£o estiver PRONTO ou alÃ©m
  â€¢ Pedido completo sÃ³ Ã© ENTREGUE se TODOS SubPedidos estÃ£o ENTREGUE
  â€¢ MudanÃ§a de estado SEMPRE gera EventLog
  â€¢ MudanÃ§a de estado SEMPRE atualiza @Version (concorrÃªncia)
  â€¢ Tentativa de transiÃ§Ã£o invÃ¡lida lanÃ§a BusinessException clara

â–¡ Implementar mÃ©todo de validaÃ§Ã£o central:
  â€¢ SubPedidoService.validarTransicao(estadoAtual, estadoNovo, role)
  â€¢ Retorna: sucesso ou exceÃ§Ã£o explicativa
  â€¢ Centraliza TODA lÃ³gica de transiÃ§Ã£o

â–¡ Criar testes automatizados de transiÃ§Ãµes:
  â€¢ TransiÃ§Ãµes vÃ¡lidas DEVEM funcionar
  â€¢ TransiÃ§Ãµes invÃ¡lidas DEVEM ser bloqueadas
  â€¢ PermissÃµes DEVEM ser respeitadas
  â€¢ ConcorrÃªncia DEVE ser tratada

â–¡ Garantir idempotÃªncia:
  â€¢ Marcar como PRONTO quando jÃ¡ estÃ¡ PRONTO: nÃ£o faz nada, retorna sucesso
  â€¢ Marcar como ENTREGUE quando jÃ¡ estÃ¡ ENTREGUE: nÃ£o faz nada
  â€¢ Evita erros em retries e duplicaÃ§Ãµes de rede

ARTEFATOS A GERAR/REFATORAR:
â–¡ StatusSubPedido.java (refatorado - estados oficiais)
â–¡ StatusPedido.java (refatorado - estados oficiais)
â–¡ SubPedidoService.java (refatorado - mÃ¡quina de estados)
â–¡ PedidoService.java (refatorado - agregaÃ§Ã£o de SubPedidos)
â–¡ TransicaoEstadoValidator.java (novo - validaÃ§Ã£o centralizada)
â–¡ SubPedidoStateMachineTest.java (novo - testes automatizados)
â–¡ CancelarSubPedidoRequest.java (novo DTO - com motivo obrigatÃ³rio)
â–¡ TransicaoInvalidaException.java (nova exceÃ§Ã£o especÃ­fica)
â–¡ MOTOR_OPERACIONAL_PEDIDOS.txt (relatÃ³rio tÃ©cnico)

REGRAS EXPLÃCITAS IMPLEMENTADAS:
âœ“ Estados terminais nÃ£o permitem transiÃ§Ãµes
âœ“ Cancelamento exige motivo e role adequada
âœ“ TransiÃ§Ãµes invÃ¡lidas lanÃ§am exceÃ§Ã£o clara
âœ“ Cada transiÃ§Ã£o gera evento de auditoria
âœ“ ConcorrÃªncia tratada com @Version
âœ“ Services sÃ£o idempotentes
âœ“ Regras centralizadas (nÃ£o espalhadas)

CRITÃ‰RIOS DE ACEITAÃ‡ÃƒO:
âœ“ MÃ¡quina de estados clara e documentada
âœ“ TransiÃ§Ãµes vÃ¡lidas funcionam
âœ“ TransiÃ§Ãµes invÃ¡lidas sÃ£o bloqueadas
âœ“ PermissÃµes por role respeitadas
âœ“ EventLog registra todas transiÃ§Ãµes
âœ“ Testes automatizados passam 100%
âœ“ Nenhuma lÃ³gica de estado fora do Service
âœ“ Sistema funciona sem UI (testÃ¡vel via API REST)

TEMPO ESTIMADO: 4-5 dias
COMPLEXIDADE: ALTA
RISCO: MÃ‰DIO (mudanÃ§a de comportamento existente)

COMO VALIDAR:
CenÃ¡rio 1: Cozinha marca SubPedido como PRONTO
  â†’ POST /api/sub-pedidos/{id}/status (body: {"novoStatus": "PRONTO"})
  â†’ Deve funcionar se estado atual for EM_PREPARACAO
  â†’ Deve falhar se estado atual for CRIADO ou ENTREGUE

CenÃ¡rio 2: Cliente tenta cancelar SubPedido
  â†’ POST /api/sub-pedidos/{id}/cancelar (role: CLIENTE)
  â†’ Deve falhar com 403 Forbidden

CenÃ¡rio 3: Gerente cancela SubPedido EM_PREPARACAO
  â†’ POST /api/sub-pedidos/{id}/cancelar (role: GERENTE, body: {"motivo": "Cliente desistiu"})
  â†’ Deve funcionar e gerar EventLog

CenÃ¡rio 4: ConcorrÃªncia - dois garÃ§ons assumem mesmo pedido
  â†’ Thread 1: PRONTO â†’ EM_ENTREGA
  â†’ Thread 2: PRONTO â†’ EM_ENTREGA (simultÃ¢neo)
  â†’ Um deve funcionar, outro deve receber OptimisticLockException


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ETAPA PRIORITÃRIA 2 â€” FILA OPERACIONAL INTELIGENTE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STATUS: â¸ï¸ AGUARDANDO ETAPA PRIORITÃRIA 1

OBJETIVO:
Implementar uma fila lÃ³gica de atendimento no BACKEND que organiza
automaticamente o trabalho, elimina decisÃµes manuais e roteia
responsabilidades sem depender de chamadas verbais ou UI.

CONTEXTO:
Em ambientes reais:
â€¢ MÃºltiplos garÃ§ons disputam os mesmos pedidos
â€¢ Cozinhas ficam sobrecarregadas enquanto outras ficam ociosas
â€¢ NinguÃ©m sabe "quem pega o quÃª"
â€¢ Pedidos ficam prontos mas nÃ£o sÃ£o entregues
â€¢ Caos organizacional total

O backend DEVE organizar este caos atravÃ©s de roteamento automÃ¡tico.

ATIVIDADES:
â–¡ Criar entity FilaOperacional
  â€¢ id, tipo (COZINHA, ENTREGA, ATENDIMENTO)
  â€¢ SubPedido associado
  â€¢ ResponsÃ¡vel atual (User)
  â€¢ Status (AGUARDANDO, ASSUMIDO, CONCLUIDO)
  â€¢ Prioridade (calculada automaticamente)
  â€¢ Timestamp de entrada na fila
  â€¢ Tempo de espera (calculado)

â–¡ Criar FilaOperacionalService com lÃ³gicas:
  â€¢ adicionarNaFila(SubPedido, TipoFila)
  â€¢ assumirProximoDaFila(User user, TipoFila tipo) â†’ retorna SubPedido ou null
  â€¢ calcularPrioridade(SubPedido) â†’ considera tempo de espera, tipo de cliente, urgÃªncia
  â€¢ buscarMeuItens(User user) â†’ itens assumidos pelo usuÃ¡rio
  â€¢ liberarItem(SubPedido) â†’ remove da fila (conclusÃ£o ou cancelamento)
  â€¢ reatribuir(SubPedido, User novoResponsavel) â†’ intervenÃ§Ã£o gerencial

â–¡ Integrar com SubPedidoService:
  â€¢ Ao criar SubPedido (CRIADO â†’ PENDENTE): adicionar em FilaCozinha
  â€¢ Ao marcar como PRONTO: adicionar em FilaEntrega
  â€¢ Ao assumir (garÃ§om): marcar item como ASSUMIDO na fila
  â€¢ Ao entregar: remover da fila (CONCLUIDO)
  â€¢ Ao cancelar: remover da fila

â–¡ Implementar roteamento automÃ¡tico:
  â€¢ POST /api/fila/cozinha/assumir-proximo
    â†’ Backend decide qual SubPedido o usuÃ¡rio deve pegar
    â†’ CritÃ©rios: prioridade, tempo de espera, cozinha do usuÃ¡rio
    â†’ Retorna SubPedido ou "fila vazia"
  
  â€¢ POST /api/fila/entrega/assumir-proximo
    â†’ Backend decide qual SubPedido o garÃ§om deve entregar
    â†’ CritÃ©rios: prioridade, proximidade, carga atual do garÃ§om
    â†’ Retorna SubPedido ou "fila vazia"

â–¡ Implementar regras de negÃ³cio:
  â€¢ Item na fila NÃƒO pode ser assumido por dois usuÃ¡rios simultaneamente
  â€¢ Item assumido hÃ¡ mais de X minutos sem progresso volta para fila (timeout)
  â€¢ Prioridade aumenta automaticamente com tempo de espera
  â€¢ Gerente pode reatribuir item forÃ§adamente
  â€¢ Backend registra QUEM assumiu e QUANDO (auditoria)

â–¡ Implementar mÃ©tricas operacionais:
  â€¢ Tamanho atual da fila por tipo
  â€¢ Tempo mÃ©dio de espera por tipo
  â€¢ Taxa de conclusÃ£o por responsÃ¡vel
  â€¢ Itens em timeout (assumidos mas nÃ£o concluÃ­dos)
  â€¢ DistribuiÃ§Ã£o de carga por responsÃ¡vel

â–¡ Criar endpoints de monitoramento:
  â€¢ GET /api/fila/cozinha/tamanho
  â€¢ GET /api/fila/entrega/tamanho
  â€¢ GET /api/fila/cozinha/itens (lista completa - GERENTE)
  â€¢ GET /api/fila/meus-itens (itens assumidos pelo usuÃ¡rio logado)
  â€¢ GET /api/fila/metricas (dashboard operacional - GERENTE)

â–¡ Garantir concorrÃªncia segura:
  â€¢ Usar lock otimista (@Version) ao assumir item
  â€¢ Transaction isolation adequado
  â€¢ Testes de concorrÃªncia (mÃºltiplos usuÃ¡rios assumindo simultaneamente)

ARTEFATOS A GERAR:
â–¡ FilaOperacional.java (entity nova)
â–¡ TipoFila.java (enum: COZINHA, ENTREGA, ATENDIMENTO)
â–¡ StatusFilaItem.java (enum: AGUARDANDO, ASSUMIDO, CONCLUIDO, TIMEOUT)
â–¡ FilaOperacionalRepository.java (queries especializadas)
â–¡ FilaOperacionalService.java (lÃ³gica de fila)
â–¡ FilaController.java (endpoints REST)
â–¡ FilaMetricsDTO.java (mÃ©tricas operacionais)
â–¡ SubPedidoService.java (refatorado - integraÃ§Ã£o com fila)
â–¡ FilaConcurrencyTest.java (testes de concorrÃªncia)
â–¡ FILA_OPERACIONAL_INTELIGENTE.txt (relatÃ³rio tÃ©cnico)

REGRAS EXPLÃCITAS IMPLEMENTADAS:
âœ“ Backend decide quem deve fazer o quÃª
âœ“ Nenhuma decisÃ£o de roteamento na UI
âœ“ Item assumido Ã© bloqueado para outros
âœ“ Timeout automÃ¡tico libera itens abandonados
âœ“ Prioridade calculada automaticamente
âœ“ MÃ©tricas operacionais em tempo real
âœ“ ConcorrÃªncia tratada com locks

CRITÃ‰RIOS DE ACEITAÃ‡ÃƒO:
âœ“ SubPedido entra automaticamente na fila ao ser criado
âœ“ UsuÃ¡rio pode "assumir prÃ³ximo" via API
âœ“ Backend decide qual item retornar (prioridade)
âœ“ Item assumido nÃ£o Ã© retornado para outro usuÃ¡rio
âœ“ Item timeout volta automaticamente para fila
âœ“ Gerente pode reatribuir forÃ§adamente
âœ“ MÃ©tricas operacionais funcionam
âœ“ Testes de concorrÃªncia passam
âœ“ Sistema funciona sem UI (testÃ¡vel via API)

TEMPO ESTIMADO: 5-6 dias
COMPLEXIDADE: ALTA
RISCO: MÃ‰DIO (concorrÃªncia complexa)

COMO VALIDAR:
CenÃ¡rio 1: Cozinheiro assume prÃ³ximo da fila
  â†’ POST /api/fila/cozinha/assumir-proximo (role: COZINHA)
  â†’ Backend retorna SubPedido com maior prioridade
  â†’ PrÃ³xima chamada retorna SubPedido diferente

CenÃ¡rio 2: Dois cozinheiros assumem simultaneamente
  â†’ Thread 1: POST /api/fila/cozinha/assumir-proximo
  â†’ Thread 2: POST /api/fila/cozinha/assumir-proximo (simultÃ¢neo)
  â†’ DEVE retornar SubPedidos diferentes (nÃ£o duplicar)

CenÃ¡rio 3: Item abandonado volta para fila
  â†’ Cozinheiro assume item Ã s 10:00
  â†’ NÃ£o conclui em 15 minutos
  â†’ Ã€s 10:16, item volta para fila automaticamente (job agendado)

CenÃ¡rio 4: Gerente reatribui item
  â†’ POST /api/fila/reatribuir/{itemId} (role: GERENTE, body: {"novoResponsavelId": 123})
  â†’ Item Ã© reatribuÃ­do
  â†’ EventLog registra intervenÃ§Ã£o gerencial


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ETAPAS ADIADAS - NÃƒO IMPLEMENTAR AGORA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

As seguintes etapas foram REMOVIDAS da ordem prioritÃ¡ria e sÃ³ devem
ser implementadas APÃ“S consolidaÃ§Ã£o do motor operacional e fila:

ðŸ”„ ETAPA 07 - Sistema de ImpressÃ£o e Bridge Local
   â†’ ADIADO atÃ© motor operacional estÃ¡vel
   â†’ Depende de WebSocket e UI
   â†’ NÃ£o Ã© crÃ­tico para funcionamento do backend

ðŸ”„ ETAPA 08 - NotificaÃ§Ãµes em Tempo Real (WebSocket)
   â†’ ADIADO atÃ© fila operacional validada
   â†’ Ã‰ camada de apresentaÃ§Ã£o
   â†’ Backend funciona sem notificaÃ§Ãµes push

ðŸ”„ ETAPA 09 - Painel Operacional Mobile (GarÃ§ons)
   â†’ ADIADO atÃ© backend sÃ³lido
   â†’ Ã‰ camada de UI
   â†’ Backend provÃª APIs, UI consome

ðŸ”„ ETAPA 10 - Painel Cozinha Especializado
   â†’ ADIADO atÃ© backend sÃ³lido
   â†’ Ã‰ camada de UI
   â†’ Backend provÃª APIs, UI consome

ðŸ”„ ETAPA 11 - Painel Gerencial com IntervenÃ§Ãµes
   â†’ ADIADO atÃ© backend sÃ³lido
   â†’ Ã‰ camada de UI
   â†’ Backend provÃª APIs, UI consome

MOTIVO DO ADIAMENTO:
Essas etapas sÃ£o camadas de APRESENTAÃ‡ÃƒO que CONSOMEM o backend.
Primeiro precisamos de um backend SÃ“LIDO, TESTÃVEL e FUNCIONAL.
Depois construÃ­mos UIs que consomem as APIs.

Ordem correta: DOMÃNIO â†’ API â†’ UI


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ETAPA 12 - OTIMIZAÃ‡ÃƒO E ESCALABILIDADE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STATUS: â¸ï¸ AGUARDANDO ETAPAS PRIORITÃRIAS 1-2

OBJETIVO:
Preparar sistema para alto volume com cache, paginaÃ§Ã£o, otimizaÃ§Ãµes de
queries e Ã­ndices estratÃ©gicos. Esta etapa PERMANECE relevante pois
otimiza o BACKEND, nÃ£o a UI.

ATIVIDADES:
â–¡ Configurar Redis para cache distribuÃ­do
â–¡ Implementar cache de produtos (cardÃ¡pio)
â–¡ Implementar cache de configuraÃ§Ãµes do sistema
â–¡ Adicionar paginaÃ§Ã£o em todas listagens
â–¡ Otimizar queries com DTO projetado
â–¡ Configurar connection pool do PostgreSQL
â–¡ Adicionar Ã­ndices estratÃ©gicos adicionais
â–¡ Implementar batch processing onde aplicÃ¡vel
â–¡ Otimizar lazy loading
â–¡ Configurar query hints

ARTEFATOS A GERAR:
â–¡ RedisConfig.java
â–¡ CacheConfig.java
â–¡ RefatoraÃ§Ã£o de Repositories (paginaÃ§Ã£o)
â–¡ RefatoraÃ§Ã£o de DTOs (projeÃ§Ã£o)
â–¡ Migration SQL (novos Ã­ndices)
â–¡ PerformanceTest.java
â–¡ OTIMIZACAO_ESCALABILIDADE.txt

CRITÃ‰RIOS DE ACEITAÃ‡ÃƒO:
âœ“ Redis configurado e funcional
âœ“ Queries com paginaÃ§Ã£o
âœ“ Cache hit rate > 70% para produtos
âœ“ Tempo de resposta < 200ms para 90% requests
âœ“ Suporta 1000 pedidos simultÃ¢neos

TEMPO ESTIMADO: 5-6 dias
COMPLEXIDADE: ALTA
RISCO: MÃ‰DIO


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ETAPA 13 - MONITORAMENTO E OBSERVABILIDADE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STATUS: â¸ï¸ AGUARDANDO ETAPA 12

OBJETIVO:
Implementar stack completo de observabilidade com mÃ©tricas, logs e traces.
Esta etapa PERMANECE relevante pois monitora o BACKEND.

ATIVIDADES:
â–¡ Configurar Micrometer + Prometheus
â–¡ Criar mÃ©tricas de negÃ³cio (pedidos/min, tempo mÃ©dio preparo)
â–¡ Configurar exportaÃ§Ã£o de mÃ©tricas
â–¡ Configurar health checks customizados
â–¡ Implementar distributed tracing (opcional)
â–¡ Configurar alertas crÃ­ticos
â–¡ Criar dashboard Grafana
â–¡ Implementar mÃ©tricas de performance de queries
â–¡ Configurar logging estruturado (JSON)

ARTEFATOS A GERAR:
â–¡ MetricsConfig.java
â–¡ BusinessMetricsService.java
â–¡ HealthCheckConfig.java
â–¡ prometheus.yml
â–¡ grafana-dashboard.json
â–¡ MONITORAMENTO_OBSERVABILIDADE.txt

CRITÃ‰RIOS DE ACEITAÃ‡ÃƒO:
âœ“ Prometheus coletando mÃ©tricas
âœ“ Dashboard Grafana funcional
âœ“ Health checks respondendo
âœ“ Alertas configurados
âœ“ MÃ©tricas de negÃ³cio visÃ­veis

TEMPO ESTIMADO: 3-4 dias
COMPLEXIDADE: MÃ‰DIA
RISCO: BAIXO


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ETAPA 14 - FUNDO DE CONSUMO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STATUS: â¸ï¸ AGUARDANDO ETAPA 13

OBJETIVO:
Implementar sistema de saldo prÃ©-carregado para consumo rÃ¡pido em eventos
e hotÃ©is. Esta etapa PERMANECE relevante pois Ã© lÃ³gica de DOMÃNIO.

ATIVIDADES:
â–¡ Criar entity FundoConsumo
â–¡ Criar entity TransacaoFundo
â–¡ Implementar carregamento de saldo
â–¡ Implementar dÃ©bito automÃ¡tico ao criar pedido
â–¡ Implementar validaÃ§Ã£o de saldo suficiente
â–¡ Implementar estorno em caso de cancelamento
â–¡ Criar endpoint de consulta de saldo
â–¡ Criar endpoint de histÃ³rico de transaÃ§Ãµes
â–¡ Implementar recarga de saldo
â–¡ Implementar fechamento de fundo (devoluÃ§Ã£o de troco)

ARTEFATOS A GERAR:
â–¡ FundoConsumo.java
â–¡ TransacaoFundo.java
â–¡ TipoTransacao.java (enum)
â–¡ FundoConsumoService.java
â–¡ FundoConsumoController.java
â–¡ FUNDO_CONSUMO.txt

CRITÃ‰RIOS DE ACEITAÃ‡ÃƒO:
âœ“ Saldo carregado corretamente
âœ“ DÃ©bito automÃ¡tico funciona
âœ“ Pedido rejeitado se saldo insuficiente
âœ“ Estorno funciona
âœ“ HistÃ³rico completo e auditÃ¡vel

TEMPO ESTIMADO: 4-5 dias
COMPLEXIDADE: MÃ‰DIA-ALTA
RISCO: MÃ‰DIO (transaÃ§Ãµes financeiras)


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ETAPA 15 - TESTES E2E E DOCUMENTAÃ‡ÃƒO FINAL
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STATUS: â¸ï¸ AGUARDANDO ETAPA 14

OBJETIVO:
Criar suite completa de testes end-to-end simulando fluxos reais e
documentaÃ§Ã£o tÃ©cnica completa do sistema BACKEND.

ATIVIDADES:
â–¡ Criar testes E2E de fluxo completo (criaÃ§Ã£o â†’ entrega via API)
â–¡ Criar testes de concorrÃªncia pesada (mÃºltiplos atores simultÃ¢neos)
â–¡ Criar testes de carga (JMeter/Gatling - APIs REST)
â–¡ Documentar arquitetura completa
â–¡ Documentar decisÃµes tÃ©cnicas
â–¡ Criar guia de deployment
â–¡ Criar guia de troubleshooting
â–¡ Documentar APIs (Swagger aprimorado)
â–¡ Criar manual de operaÃ§Ã£o
â–¡ Criar runbook de incidentes

ARTEFATOS A GERAR:
â–¡ E2EFluxoCompletoTest.java
â–¡ ConcurrencyLoadTest.java
â–¡ PerformanceLoadTest.jmx (JMeter)
â–¡ ARQUITETURA_FINAL.md
â–¡ DEPLOYMENT_GUIDE.md
â–¡ TROUBLESHOOTING.md
â–¡ OPERATIONS_MANUAL.md
â–¡ INCIDENT_RUNBOOK.md
â–¡ TESTES_E2E_DOCUMENTACAO.txt

CRITÃ‰RIOS DE ACEITAÃ‡ÃƒO:
âœ“ Testes E2E passam 100%
âœ“ Sistema suporta carga especificada
âœ“ DocumentaÃ§Ã£o completa e clara
âœ“ Guias testados e validados
âœ“ Sistema pronto para produÃ§Ã£o

TEMPO ESTIMADO: 6-7 dias
COMPLEXIDADE: MÃ‰DIA
RISCO: BAIXO


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
RESUMO EXECUTIVO - REORGANIZADO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SITUAÃ‡ÃƒO ATUAL:
âœ… 6 etapas fundacionais CONCLUÃDAS (40%)
âœ… Base sÃ³lida: ConcorrÃªncia + Auditoria + DomÃ­nio + EventLog + SeguranÃ§a + QR Code
âœ… 107 arquivos Java compilados
âœ… ~15.000 linhas de cÃ³digo
âœ… BUILD SUCCESS

NOVA ORDEM DE PRIORIDADES:

CRÃTICO (FAZER AGORA):
1ï¸âƒ£ ETAPA PRIORITÃRIA 1 - Motor Operacional de Pedidos (4-5 dias)
2ï¸âƒ£ ETAPA PRIORITÃRIA 2 - Fila Operacional Inteligente (5-6 dias)

IMPORTANTE (FAZER DEPOIS):
3ï¸âƒ£ ETAPA 12 - OtimizaÃ§Ã£o e Escalabilidade (5-6 dias)
4ï¸âƒ£ ETAPA 13 - Monitoramento e Observabilidade (3-4 dias)
5ï¸âƒ£ ETAPA 14 - Fundo de Consumo (4-5 dias)
6ï¸âƒ£ ETAPA 15 - Testes E2E e DocumentaÃ§Ã£o Final (6-7 dias)

ADIADO (NÃƒO FAZER AGORA):
âŒ ETAPA 07 - ImpressÃ£o (depende de UI)
âŒ ETAPA 08 - WebSocket (camada de apresentaÃ§Ã£o)
âŒ ETAPA 09 - Painel Mobile (camada de UI)
âŒ ETAPA 10 - Painel Cozinha (camada de UI)
âŒ ETAPA 11 - Painel Gerencial (camada de UI)

MOTIVO DA REORGANIZAÃ‡ÃƒO:
Backend DEVE funcionar isoladamente, sem depender de UI.
Primeiro: Motor sÃ³lido que organiza o caos operacional.
Depois: Camadas de apresentaÃ§Ã£o que CONSOMEM o backend.

PRINCÃPIO FUNDAMENTAL:
"Esta lÃ³gica pertence ao domÃ­nio ou estÃ¡ vazando para a UI?"
Se a resposta nÃ£o for clara, pertence ao domÃ­nio.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PRÃ“XIMA AÃ‡ÃƒO - CLARA E OBJETIVA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

INICIAR: ETAPA PRIORITÃRIA 1 - MOTOR OPERACIONAL DE PEDIDOS

Implementar:
âœ“ MÃ¡quina de estados explÃ­cita e robusta
âœ“ ValidaÃ§Ã£o centralizada de transiÃ§Ãµes
âœ“ Bloqueio de transiÃ§Ãµes invÃ¡lidas
âœ“ PermissÃµes por role integradas
âœ“ Cancelamento com motivo obrigatÃ³rio
âœ“ IdempotÃªncia em todas operaÃ§Ãµes
âœ“ Testes automatizados de transiÃ§Ãµes
âœ“ EventLog em todas mudanÃ§as de estado

Objetivo: Backend organiza o ciclo de vida do pedido sem depender de UI
Tempo estimado: 4-5 dias
Complexidade: ALTA
Risco: MÃ‰DIO

RESULTADO ESPERADO:
Backend capaz de gerenciar pedidos de forma autÃ´noma, testÃ¡vel e robusta,
servindo de fundaÃ§Ã£o para qualquer camada de apresentaÃ§Ã£o futura.


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FIM DO PLANO REORGANIZADO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ãšltima atualizaÃ§Ã£o: 10 de Fevereiro de 2026
PrÃ³xima revisÃ£o: ApÃ³s conclusÃ£o da Etapa PrioritÃ¡ria 1
